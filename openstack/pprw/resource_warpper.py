import webob.dec
import webob.exc
from webob import Request
from webob import Response
import six
from oslo_serialization import jsonutils

_METHODS_WITH_BODY = [
    'POST',
    'PUT',
]

_ROUTES_METHODS = [
    'create',
    'delete',
    'show',
    'update',
]

_SUPPORTED_CONTENT_TYPES = (
    'application/json',
    'application/vnd.openstack.compute+json',
)

def get_supported_content_types():
    return _SUPPORTED_CONTENT_TYPES

def action_peek(body):
    """Determine action to invoke.

    This looks inside the json body and fetches out the action method
    name.
    """

    try:
        decoded = jsonutils.loads(body)
    except ValueError:
        msg = _("cannot understand JSON")
        raise Exception(reason=msg)

    # Make sure there's exactly one key...
    if len(decoded) != 1:
        msg = _("too many body keys")
        raise Exception(reason=msg)

    # Return the action name
    return list(decoded.keys())[0]

class MetaRequest(webob.Request):
    def __init__(self, environ, *args, **kwargs):
        super(MetaRequest, self).__init__(environ, *args, **kwargs)

class Request(MetaRequest):
    """Add some OpenStack API-specific logic to the base webob.Request."""

    def __init__(self, *args, **kwargs):
        super(Request, self).__init__(*args, **kwargs)

    def best_match_content_type(self):
        """Determine the requested response content-type."""
        if 'nova.best_content_type' not in self.environ:
            # Calculate the best MIME type
            content_type = None

            # Check URL path suffix
            parts = self.path.rsplit('.', 1)
            if len(parts) > 1:
                possible_type = 'application/' + parts[1]
                if possible_type in get_supported_content_types():
                    content_type = possible_type

            if not content_type:
                best_matches = self.accept.acceptable_offers(
                    get_supported_content_types())
                if best_matches:
                    content_type = best_matches[0][0]

            self.environ['nova.best_content_type'] = (content_type or
                                                      'application/json')

        return self.environ['nova.best_content_type']

    def get_content_type(self):
        """Determine content type of the request body.

        Does not do any body introspection, only checks header

        """
        if "Content-Type" not in self.headers:
            return None

        content_type = self.content_type

        # NOTE(markmc): text/plain is the default for eventlet and
        # other webservers which use mimetools.Message.gettype()
        # whereas twisted defaults to ''.
        if not content_type or content_type == 'text/plain':
            return None

        if content_type not in get_supported_content_types():
            raise Exception(content_type=content_type)

        return content_type

class ResourceExceptionHandler(object):
    """Context manager to handle Resource exceptions.

    Used when processing exceptions generated by API implementation
    methods.  Converts most exceptions to Fault
    exceptions, with the appropriate logging.
    """

    def __enter__(self):
        return None

    def __exit__(self, ex_type, ex_value, ex_traceback):
        if not ex_value:
            return True

        # We didn't handle the exception
        return False

class Resource:
    def __init__(self, controller):

        self.controller = controller

        # Copy over the actions dictionary
        self.wsgi_actions = {}
        if controller:
            self.register_actions(controller)

    def register_actions(self, controller):
        """Registers controller actions with this resource."""

        actions = getattr(controller, 'wsgi_actions', {})
        for key, method_name in actions.items():
            self.wsgi_actions[key] = getattr(controller, method_name)
    
    def _should_have_body(self, request):
        return request.method in _METHODS_WITH_BODY
        
    @webob.dec.wsgify(RequestClass=Request)
    def __call__(self, request):
        """WSGI method that controls (de)serialization and method dispatch."""

        # Identify the action, its arguments, and the requested
        # content type
        action_args = self.get_action_args(request.environ)
        action = action_args.pop('action', None)

        # NOTE(sdague): we filter out InvalidContentTypes early so we
        # know everything is good from here on out.
        try:
            content_type, body = self.get_body(request)
            accept = request.best_match_content_type()
        except Exception as e:
            msg = ("Unsupported Content-Type")

        return self._process_stack(request, action, action_args,
                               content_type, body, accept)

    def get_action_args(self, request_environment):
        """Parse dictionary created by routes library."""

        # NOTE(Vek): Check for get_action_args() override in the
        # controller
        if hasattr(self.controller, 'get_action_args'):
            return self.controller.get_action_args(request_environment)

        try:
            args = request_environment['wsgiorg.routing_args'][1].copy()
        except (KeyError, IndexError, AttributeError):
            return {}

        try:
            del args['controller']
        except KeyError:
            pass

        try:
            del args['format']
        except KeyError:
            pass

        return args

    def get_body(self, request):
        content_type = request.get_content_type()

        return content_type, request.body
    
    def get_method(self, request, action, content_type, body):
        meth = self._get_method(request,
                                action,
                                content_type,
                                body)
        return meth

    def _get_method(self, request, action, content_type, body):
        """Look up the action-specific method."""
        # Look up the method
        try:
            if not self.controller:
                meth = getattr(self, action)
            else:
                meth = getattr(self.controller, action)
            return meth
        except AttributeError:
            if (not self.wsgi_actions or
                    action not in _ROUTES_METHODS + ['action']):
                # Propagate the error
                raise
        if action == 'action':
            action_name = action_peek(body)
        else:
            action_name = action

        # Look up the action method
        return (self.wsgi_actions[action_name])
    
    def _get_request_content(self, body, request):
        contents = {}
        if self._should_have_body(request):
            # allow empty body with PUT and POST
            if request.content_length == 0 or request.content_length is None:
                contents = {'body': None}
            else:
                contents = self.deserialize(body)
        return contents

    
    def _process_stack(self, request, action, action_args,
                       content_type, body, accept):
        """Implement the processing stack."""

        # Get the implementing method
        try:
            meth = self.get_method(request, action,
                                   content_type, body)
        except (AttributeError, TypeError):
            raise
        except KeyError as ex:
            msg = _("There is no such action: %s") % ex.args[0]
            raise Exception(msg)
        except Exception as e:
            msg = _("Malformed request body")
            raise Exception(msg)

        if body:
            msg = _("Action: '%(action)s', calling method: %(meth)s, body: "
                    "%(body)s") % {'action': action,
                                   'body': six.text_type(body, 'utf-8'),
                                   'meth': str(meth)}

        # Now, deserialize the request body...
        try:
            contents = self._get_request_content(body, request)
        except Exception as e:
            msg = _("Malformed request body")
            raise

        # Update the action args
        action_args.update(contents)

        project_id = action_args.pop("project_id", None)
        context = request.environ.get('nova.context')
        if (context and project_id and (project_id != context.project_id)):
            msg = _("Malformed request URL: URL's project_id '%(project_id)s'"
                    " doesn't match Context's project_id"
                    " '%(context_project_id)s'") % \
                    {'project_id': project_id,
                     'context_project_id': context.project_id}
            raise

        response = None
        try:
            with ResourceExceptionHandler():
                action_result = self.dispatch(meth, request, action_args)
        except Exception as ex:
            response = ex

        if not response:
            response = Response(body=str(action_result), content_type='text/plain')

        return response
    
    def dispatch(self, method, request, action_args):
        """Dispatch a call to the action-specific method."""

        try:
            return method(req=request, **action_args)
        except Exception as e:
            # We deliberately don't return any message information
            # about the exception to the user so it looks as if
            # the method is simply not implemented.
            raise